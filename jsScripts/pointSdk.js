/* eslint-disable */
(()=>{var e=(e,t)=>{class o extends Error{}class n extends Error{}class a extends Error{}class r extends Error{}class s extends Error{}class i extends Error{}const c=async(t,n,a)=>{try{const r=await window.top.fetch(`${e}${a?"/point_api/":"/v1/api/"}${t}`,{cache:"no-cache",credentials:"include",keepalive:!0,...n,headers:{"Content-Type":"application/json",...n?.headers}});if(!r.ok){const{ok:e,status:t,statusText:n,headers:a}=r;throw console.error("SDK call failed:",{ok:e,status:t,statusText:n,headers:Object.fromEntries([...a.entries()])}),new o("Point SDK request failed")}try{return await r.json()}catch(e){throw console.error("Point API response parsing error:",e),e}}catch(e){throw console.error("Point API call failed:",e),e}},d={get:(e,t,o,n)=>c(`${e}${t?"?":""}${new URLSearchParams(t).toString()}`,{method:"GET",headers:o},n),post:(e,t,o,n)=>c(e,{method:"POST",headers:o,body:JSON.stringify({...t,_csrf:window.localStorage.getItem("csrf_token")})},n),postFile:(t,n)=>(async(t,n)=>{try{const a=await window.top.fetch(`${e}/${t}`,{cache:"no-cache",credentials:"include",keepalive:!0,...n});if(!a.ok){const{ok:e,status:t,statusText:n,headers:r}=a;throw console.error("SDK ZProxy call failed:",{ok:e,status:t,statusText:n,headers:Object.fromEntries([...r.entries()])}),new o("Point SDK request failed")}try{return await a.json()}catch(e){throw console.error("Point API response parsing error:",e),e}}catch(e){throw console.error("Point API call failed:",e),e}})(t,{method:"POST",body:n})};function l(e){return new Promise((t=>setTimeout(t,e)))}const w={},p={},u={},h="subscription_confirmation",g="subscription_cancellation",m="subscription_event",y="subscription_error",f="subscribeContractEvent",_="removeSubscriptionById",b=({type:e,params:{contract:t,event:o}={}})=>`${e}_${t}_${o}`,S=e=>p[e]||(p[e]=[]),E={},v=(e,{messageQueueSizeLimit:t=1e3}={})=>new Promise(((o,c)=>{if(void 0!==w[e])return void o(w[e]);const d=new WebSocket(`${e}?token=POINTSDK_TOKEN`);d.onopen=()=>o(Object.assign(w[e]=d,{async subscribeToContractEvent(e){const t={type:f,params:e},o=b(t);E[o]=function(){let e=()=>{},t=()=>{};return Object.assign(new Promise(((o,n)=>{e=o,t=n})),{resolve:e,reject:t})}(),await d.send(JSON.stringify(t));const n=await Promise.race([E[o],(a=1e4,new Promise(((e,t)=>setTimeout((()=>t(new s("Subscription confirmation timeout"))),a))))]);var a;const r=S(n);return Object.assign((async()=>{for(;;)try{const e=u[n];if(e)throw e;if(r.length)return r.shift();await l(100)}catch(e){throw console.error("subscribed message error:",e),e}}),{unsubscribe:()=>d.send(JSON.stringify({type:_,params:{subscriptionId:n}}))})}})),d.onerror=e=>{for(const t in p)u[t]||(u[t]=new a(e.toString()))},d.onclose=t=>{if(delete w[e],1e3===t.code||1001===t.code)o(void 0);else{for(const e in p)u[e]||(u[e]=new r(t.toString()));c()}},d.onmessage=e=>{try{const{type:o,request:a,subscriptionId:r,data:s}=JSON.parse(e.data);switch(o){case h:{const e=b(a),{resolve:t,reject:o}=E[e]||{};"string"!=typeof r?"function"==typeof o&&o(new i(`Invalid subscription id "${r}" for request id: "${e}"`)):"function"==typeof t&&t(r);break}case g:r&&(console.info({type:o,request:a,subscriptionId:r,data:s}),delete p[r],delete u[r]);break;case m:if(r){const e=S(r);e.length>t?u[r]=new n("ZProxy WS message queue overflow"):e.push(s)}else console.error("Unable to identify subscription channel",{subscriptionId:r,request:a,data:s});break;case y:r?u[r]=new i(JSON.stringify(s)):console.error("Unable to identify subscription channel",{subscriptionId:r,request:a,data:s});break;default:console.error("Unsupported event type:",{type:o,request:a,subscriptionId:r,data:s})}}catch(e){console.error("Web Socket onmessage error:",e)}}})),k=e=>new Promise(((t,o)=>{const n=Math.random(),a=e=>{e.data.__page_req_id===n&&"to_page"===e.data.__direction&&(window.removeEventListener("message",a),e.data.code?o({code:e.data.code,message:e.data.message}):t(e.data.result))};window.addEventListener("message",a),window.postMessage({messageId:e,__message_type:"registerHandler",__page_req_id:n,__direction:"to_bg"})}));return{version:t,status:{ping:()=>d.get("status/ping",void 0,{"wallet-token":"WALLETID-PASSCODE"})},contract:{load:({contract:e,...t})=>d.get(`contract/load/${e}`,t,{"wallet-token":"WALLETID-PASSCODE"}),call:async({contract:e,method:t,params:o})=>{console.log({contract:e,method:t,params:o});const{data:{abi:n,address:a}}=await d.get(`contract/load/${e}`,{},{"wallet-token":"WALLETID-PASSCODE"});console.log({abi:n,address:a});const r=n.find((e=>e.name===t));if(console.log({jsonInterface:r}),!r)throw new Error(`Method ${t} not found in contract ${e}`);const s=o??[];if(s.length!==r.inputs.length)throw new Error(`Invalid number of params, expected ${r.inputs.length}, got ${s.length}`);for(let e=0;e<s.length;e++)"bytes32"!==r.inputs[e].internalType||"string"!=typeof s[e]||s[e].startsWith("0x")||(s[e]=`0x${s[e]}`);console.log({jsonInterface:r,preparedParams:s});const{data:i}=await d.post("contract/encodeFunctionCall",{jsonInterface:r,params:s},{"wallet-token":"WALLETID-PASSCODE"});console.log({postData:i});const c=await window.top.ethereum.request({method:"eth_requestAccounts"});switch(console.log({accounts:c}),r.stateMutability){case"view":case"pure":console.log("view pure");const t=await window.top.ethereum.request({method:"eth_call",params:[{from:c[0],to:a,data:i},"latest"]});console.log({rawRes:t});const o=await d.post("contract/decodeParameters",{typesArray:r.outputs,hexString:t},{"wallet-token":"WALLETID-PASSCODE"});return console.log({decodedRes:o}),{data:o.data[0]};case"nonpayable":return window.top.ethereum.request({meta:{contract:e},method:"eth_sendTransaction",params:[{from:c[0],to:a,data:i}]});case"payable":throw new Error("Do not use call for payable functions, use send instead");default:throw new Error(`Unexpected function state mutability ${r.stateMutability}`)}},send:async({contract:e,method:t,params:o,value:n})=>{const{data:{abi:a,address:r}}=await d.get(`contract/load/${e}`,{},{"wallet-token":"WALLETID-PASSCODE"}),s=await window.top.ethereum.request({method:"eth_requestAccounts"}),i=a.find((e=>e.name===t));if(!i)throw new Error(`Method ${t} not found in contract ${e}`);const c=o??[];if(c.length!==i.inputs.length)throw new Error(`Invalid number of params, expected ${i.inputs.length}, got ${c.length}`);for(let e=0;e<c.length;e++)"bytes32"!==i.inputs[e].internalType||"string"!=typeof c[e]||c[e].startsWith("0x")||(c[e]=`0x${c[e]}`);if(["view","pure"].includes(i.stateMutability))throw new Error(`Method ${t} is a view one, use call instead of send`);const{data:l}=await d.post("contract/encodeFunctionCall",{jsonInterface:i,params:o??[]});return window.top.ethereum.request({meta:{contract:e},method:"eth_sendTransaction",params:[{from:s[0],to:r,data:l,value:n}]})},events:e=>d.post("contract/events",e,{"wallet-token":"WALLETID-PASSCODE"}),async subscribe({contract:t,event:n,...a}){if("string"!=typeof t)throw new o(`Invalid contract ${t}`);if("string"!=typeof n)throw new o(`Invalid event ${n}`);const r=new URL(e);r.protocol="https:"===r.protocol?"wss:":"ws:",r.pathname+=r.pathname.endsWith("/")?"ws":"/ws";const s=await v(r.toString());if(!s)throw new o("Failed to establish web socket connection");return s.subscribeToContractEvent({contract:t,event:n,...a})}},storage:{postFile:e=>d.postFile("_storage/",e),getString:({id:e,...t})=>d.get(`storage/getString/${e}`,t,{"wallet-token":"WALLETID-PASSCODE"}),putString:e=>d.post("storage/putString",e,{"wallet-token":"WALLETID-PASSCODE"})},wallet:{address:()=>d.get("wallet/address"),..."https://confirmation-window"===e?{hash:()=>d.get("wallet/hash",{},{},!0)}:{},publicKey:()=>d.get("wallet/publicKey",{},{"wallet-token":"WALLETID-PASSCODE"}),balance:e=>{if(!e)throw new Error("No network specified");return d.get("wallet/balance",{network:e})},send:async({to:e,network:t,value:o})=>{const{networks:n,default_network:a}=await d.get("blockchain/networks"),r=t??a;if(!n[r])throw new Error(`Unknown network ${r}`);switch(n[r].type){case"eth":const t=await window.top.ethereum.request({method:"eth_requestAccounts"});return window.top.ethereum.request({method:"eth_sendTransaction",params:[{from:t[0],to:e,value:o}],chain:r});case"solana":return window.top.solana.request({method:"solana_sendTransaction",params:[{to:e,lamports:o}],chain:r});default:throw new Error(`Unexpected network type ${n[r].type}`)}},encryptData:({publicKey:e,data:t,...o})=>d.post("wallet/encryptData",{publicKey:e,data:t,...o},{"wallet-token":"WALLETID-PASSCODE"}),decryptData:({data:e,...t})=>d.post("wallet/decryptData",{data:e,...t},{"wallet-token":"WALLETID-PASSCODE"})},identity:{publicKeyByIdentity:({identity:e,...t})=>d.get(`identity/publicKeyByIdentity/${e}`,t,{"wallet-token":"WALLETID-PASSCODE"}),identityToOwner:({identity:e,...t})=>d.get(`identity/identityToOwner/${e}`,t,{"wallet-token":"WALLETID-PASSCODE"}),ownerToIdentity:({owner:e,...t})=>d.get(`identity/ownerToIdentity/${e}`,t,{"wallet-token":"WALLETID-PASSCODE"}),me:()=>d.get("identity/isIdentityRegistered/",void 0,{"wallet-token":"WALLETID-PASSCODE"})},..."https://point"===e?{point:{wallet_send:async({to:e,network:t,value:o})=>{const n=String(Math.random());await Promise.all([k(n),(async()=>{if(200!==(await d.post("wallet/send",{to:e,network:t,value:o,messageId:n},{},!0)).status)throw new Error("Failed to send token")})()])},wallet_send_token:async({to:e,network:t,tokenAddress:o,value:n})=>{const a=String(Math.random());await Promise.all([k(a),(async()=>{if(200!==(await d.post("wallet/sendToken",{to:e,network:t,value:n,tokenAddress:o,messageId:a},{},!0)).status)throw new Error("Failed to send token")})()])}}}:{}}};var t=()=>{function e(e){return new Promise(((t,o)=>{const n=Math.random(),a=e=>{console.log({e:e}),e.data.__page_req_id===n&&"to_page"===e.data.__direction&&(window.removeEventListener("message",a),e.data.code?o({code:e.data.code,message:e.data.message}):e.data.error?o({code:e.data.error.code,message:e.data.error.message}):t(e.data.result))};window.addEventListener("message",a),console.log({request:e,id:n}),window.postMessage({...e,__provider:"eth",__message_type:"rpc",__page_req_id:n,__direction:"to_bg"})}))}return{request:e,send:t=>e({method:t})}};var o=()=>{const e=e=>new Promise(((t,o)=>{const n=Math.random(),a=e=>{e.data.__page_req_id===n&&"to_page"===e.data.__direction&&(window.removeEventListener("message",a),e.data.code?o({code:e.data.code,message:e.data.message}):e.data.error?o({code:e.data.error.code,message:e.data.error.message}):t(e.data.result))};window.addEventListener("message",a),window.postMessage({...e,__message_type:"rpc",__provider:"solana",__page_req_id:n,__direction:"to_bg"})}));return{connect:async()=>({publicKey:(await e({method:"solana_requestAccount"})).publicKey}),disconnect:async()=>{},request:e,signAndSendTransaction:t=>e({method:"solana_sendTransaction",params:[t.toJSON()]})}};window.point=e(window.location.origin,"0.0.21"),window.ethereum=t(),window.solana=o()})();

