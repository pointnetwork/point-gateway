/* eslint-disable */
(()=>{var t=(t,e)=>{class n extends Error{}class o extends Error{}class a extends Error{}class r extends Error{}class s extends Error{}class i extends Error{}const c=async(e,o,a)=>{try{const r=await window.top.fetch(`${t}${a?"/point_api/":"/v1/api/"}${e}`,{cache:"no-cache",credentials:"include",keepalive:!0,...o,headers:{"Content-Type":"application/json",...o?.headers}});if(!r.ok){const{ok:t,status:e,statusText:o,headers:a}=r;throw console.error("SDK call failed:",{ok:t,status:e,statusText:o,headers:Object.fromEntries([...a.entries()])}),new n("Point SDK request failed")}try{return await r.json()}catch(t){throw console.error("Point API response parsing error:",t),t}}catch(t){throw console.error("Point API call failed:",t),t}},d={get:(t,e,n,o)=>c(`${t}${e?"?":""}${new URLSearchParams(e).toString()}`,{method:"GET",headers:n},o),post:(t,e,n,o)=>c(t,{method:"POST",headers:n,body:JSON.stringify({...e,_csrf:window.localStorage.getItem("csrf_token")})},o),postFile:(e,o)=>(async(e,o)=>{try{const a=await window.top.fetch(`${t}/${e}`,{cache:"no-cache",credentials:"include",keepalive:!0,...o});if(!a.ok){const{ok:t,status:e,statusText:o,headers:r}=a;throw console.error("SDK ZProxy call failed:",{ok:t,status:e,statusText:o,headers:Object.fromEntries([...r.entries()])}),new n("Point SDK request failed")}try{return await a.json()}catch(t){throw console.error("Point API response parsing error:",t),t}}catch(t){throw console.error("Point API call failed:",t),t}})(e,{method:"POST",body:o})};function l(t){return new Promise((e=>setTimeout(e,t)))}const w={},u={},p={},h="subscription_confirmation",m="subscription_cancellation",y="subscription_event",g="subscription_error",f="subscribeContractEvent",b="removeSubscriptionById",S=({type:t,params:{contract:e,event:n}={}})=>`${t}_${e}_${n}`,E=t=>u[t]||(u[t]=[]),k={},v=(t,{messageQueueSizeLimit:e=1e3}={})=>new Promise(((n,c)=>{if(void 0!==w[t])return void n(w[t]);const d=new WebSocket(`${t}?token=POINTSDK_TOKEN`);d.onopen=()=>n(Object.assign(w[t]=d,{async subscribeToContractEvent(t){const e={type:f,params:t},n=S(e);k[n]=function(){let t=()=>{},e=()=>{};return Object.assign(new Promise(((n,o)=>{t=n,e=o})),{resolve:t,reject:e})}(),await d.send(JSON.stringify(e));const o=await Promise.race([k[n],(a=1e4,new Promise(((t,e)=>setTimeout((()=>e(new s("Subscription confirmation timeout"))),a))))]);var a;const r=E(o);return Object.assign((async()=>{for(;;)try{const t=p[o];if(t)throw t;if(r.length)return r.shift();await l(100)}catch(t){throw console.error("subscribed message error:",t),t}}),{unsubscribe:()=>d.send(JSON.stringify({type:b,params:{subscriptionId:o}}))})}})),d.onerror=t=>{for(const e in u)p[e]||(p[e]=new a(t.toString()))},d.onclose=e=>{if(delete w[t],1e3===e.code||1001===e.code)n(void 0);else{for(const t in u)p[t]||(p[t]=new r(e.toString()));c()}},d.onmessage=t=>{try{const{type:n,request:a,subscriptionId:r,data:s}=JSON.parse(t.data);switch(n){case h:{const t=S(a),{resolve:e,reject:n}=k[t]||{};"string"!=typeof r?"function"==typeof n&&n(new i(`Invalid subscription id "${r}" for request id: "${t}"`)):"function"==typeof e&&e(r);break}case m:r&&(console.info({type:n,request:a,subscriptionId:r,data:s}),delete u[r],delete p[r]);break;case y:if(r){const t=E(r);t.length>e?p[r]=new o("ZProxy WS message queue overflow"):t.push(s)}else console.error("Unable to identify subscription channel",{subscriptionId:r,request:a,data:s});break;case g:r?p[r]=new i(JSON.stringify(s)):console.error("Unable to identify subscription channel",{subscriptionId:r,request:a,data:s});break;default:console.error("Unsupported event type:",{type:n,request:a,subscriptionId:r,data:s})}}catch(t){console.error("Web Socket onmessage error:",t)}}})),I=t=>new Promise(((e,n)=>{const o=Math.random(),a=t=>{t.data.__page_req_id===o&&"to_page"===t.data.__direction&&(window.removeEventListener("message",a),t.data.code?n({code:t.data.code,message:t.data.message}):e(t.data.result))};window.addEventListener("message",a),window.postMessage({messageId:t,__message_type:"registerHandler",__page_req_id:o,__direction:"to_bg"})}));return{version:e,status:{ping:()=>d.get("status/ping",void 0,{"wallet-token":"WALLETID-PASSCODE"})},contract:{load:({contract:t,...e})=>d.get(`contract/load/${t}`,e,{"wallet-token":"WALLETID-PASSCODE"}),call:async({contract:t,method:e,params:n})=>{const{data:{abi:o,address:a}}=await d.get(`contract/load/${t}`,{},{"wallet-token":"WALLETID-PASSCODE"}),r=o.find((t=>t.name===e));if(!r)throw new Error(`Method ${e} not found in contract ${t}`);const s=n??[];if(s.length!==r.inputs.length)throw new Error(`Invalid number of params, expected ${r.inputs.length}, got ${s.length}`);for(let t=0;t<s.length;t++)"bytes32"!==r.inputs[t].internalType||"string"!=typeof s[t]||s[t].startsWith("0x")||(s[t]=`0x${s[t]}`);const{data:i}=await d.post("contract/encodeFunctionCall",{jsonInterface:r,params:s},{"wallet-token":"WALLETID-PASSCODE"}),c=await window.top.ethereum.request({method:"eth_requestAccounts"});switch(r.stateMutability){case"view":case"pure":const e=await window.top.ethereum.request({method:"eth_call",params:[{from:c[0],to:a,data:i},"latest"]});return{data:(await d.post("contract/decodeParameters",{typesArray:r.outputs,hexString:e},{"wallet-token":"WALLETID-PASSCODE"})).data[0]};case"nonpayable":return window.top.ethereum.request({meta:{contract:t},method:"eth_sendTransaction",params:[{from:c[0],to:a,data:i}]});case"payable":throw new Error("Do not use call for payable functions, use send instead");default:throw new Error(`Unexpected function state mutability ${r.stateMutability}`)}},send:async({contract:t,method:e,params:n,value:o})=>{const{data:{abi:a,address:r}}=await d.get(`contract/load/${t}`,{},{"wallet-token":"WALLETID-PASSCODE"}),s=await window.top.ethereum.request({method:"eth_requestAccounts"}),i=a.find((t=>t.name===e));if(!i)throw new Error(`Method ${e} not found in contract ${t}`);const c=n??[];if(c.length!==i.inputs.length)throw new Error(`Invalid number of params, expected ${i.inputs.length}, got ${c.length}`);for(let t=0;t<c.length;t++)"bytes32"!==i.inputs[t].internalType||"string"!=typeof c[t]||c[t].startsWith("0x")||(c[t]=`0x${c[t]}`);if(["view","pure"].includes(i.stateMutability))throw new Error(`Method ${e} is a view one, use call instead of send`);const{data:l}=await d.post("contract/encodeFunctionCall",{jsonInterface:i,params:n??[]});return window.top.ethereum.request({meta:{contract:t},method:"eth_sendTransaction",params:[{from:s[0],to:r,data:l,value:o}]})},events:t=>d.post("contract/events",t,{"wallet-token":"WALLETID-PASSCODE"}),async subscribe({contract:e,event:o,...a}){if("string"!=typeof e)throw new n(`Invalid contract ${e}`);if("string"!=typeof o)throw new n(`Invalid event ${o}`);const r=new URL(t);r.protocol="https:"===r.protocol?"wss:":"ws:",r.pathname+=r.pathname.endsWith("/")?"ws":"/ws";const s=await v(r.toString());if(!s)throw new n("Failed to establish web socket connection");return s.subscribeToContractEvent({contract:e,event:o,...a})}},storage:{postFile:t=>d.postFile("_storage/",t),getString:({id:t,...e})=>d.get(`storage/getString/${t}`,e,{"wallet-token":"WALLETID-PASSCODE"}),putString:t=>d.post("storage/putString",t,{"wallet-token":"WALLETID-PASSCODE"})},wallet:{address:()=>d.get("wallet/address"),..."https://confirmation-window"===t?{hash:()=>d.get("wallet/hash",{},{},!0)}:{},publicKey:()=>d.get("wallet/publicKey",{},{"wallet-token":"WALLETID-PASSCODE"}),balance:t=>{if(!t)throw new Error("No network specified");return d.get("wallet/balance",{network:t})},send:async({to:t,network:e,value:n})=>{const{networks:o,default_network:a}=await d.get("blockchain/networks"),r=e??a;if(!o[r])throw new Error(`Unknown network ${r}`);switch(o[r].type){case"eth":const e=await window.top.ethereum.request({method:"eth_requestAccounts"});return window.top.ethereum.request({method:"eth_sendTransaction",params:[{from:e[0],to:t,value:n}],chain:r});case"solana":return window.top.solana.request({method:"solana_sendTransaction",params:[{to:t,lamports:n}],chain:r});default:throw new Error(`Unexpected network type ${o[r].type}`)}},encryptData:({publicKey:t,data:e,...n})=>d.post("wallet/encryptData",{publicKey:t,data:e,...n},{"wallet-token":"WALLETID-PASSCODE"}),decryptData:({data:t,...e})=>d.post("wallet/decryptData",{data:t,...e},{"wallet-token":"WALLETID-PASSCODE"})},identity:{publicKeyByIdentity:({identity:t,...e})=>d.get(`identity/publicKeyByIdentity/${t}`,e,{"wallet-token":"WALLETID-PASSCODE"}),identityToOwner:({identity:t,...e})=>d.get(`identity/identityToOwner/${t}`,e,{"wallet-token":"WALLETID-PASSCODE"}),ownerToIdentity:({owner:t,...e})=>d.get(`identity/ownerToIdentity/${t}`,e,{"wallet-token":"WALLETID-PASSCODE"}),me:()=>d.get("identity/isIdentityRegistered/",void 0,{"wallet-token":"WALLETID-PASSCODE"})},..."https://point"===t?{point:{wallet_send:async({to:t,network:e,value:n})=>{const o=String(Math.random());await Promise.all([I(o),(async()=>{if(200!==(await d.post("wallet/send",{to:t,network:e,value:n,messageId:o},{},!0)).status)throw new Error("Failed to send token")})()])},wallet_send_token:async({to:t,network:e,tokenAddress:n,value:o})=>{const a=String(Math.random());await Promise.all([I(a),(async()=>{if(200!==(await d.post("wallet/sendToken",{to:t,network:e,value:o,tokenAddress:n,messageId:a},{},!0)).status)throw new Error("Failed to send token")})()])}}}:{}}};window.point=t.toString()})();
//# sourceMappingURL=index.js.map
