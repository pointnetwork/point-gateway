/* eslint-disable */
(()=>{var e=(e,t)=>{class o extends Error{}class n extends Error{}class r extends Error{}class s extends Error{}class a extends Error{}class i extends Error{}const c=async(t,n)=>{try{const r=await window.top.fetch(`${e}/v1/api/${t}`,{cache:"no-cache",credentials:"include",keepalive:!0,...n,headers:{"Content-Type":"application/json",...n?.headers}});if(!r.ok){const{ok:e,status:t,statusText:n,headers:s}=r;throw console.error("SDK call failed:",{ok:e,status:t,statusText:n,headers:Object.fromEntries([...s.entries()])}),new o("Point SDK request failed")}try{return await r.json()}catch(e){throw console.error("Point API response parsing error:",e),e}}catch(e){throw console.error("Point API call failed:",e),e}},l={get:(e,t,o)=>c(`${e}${t?"?":""}${new URLSearchParams(t).toString()}`,{method:"GET",headers:o}),post:(e,t,o)=>c(e,{method:"POST",headers:o,body:JSON.stringify(t)}),postFile:(t,n)=>(async(t,n)=>{try{const r=await window.top.fetch(`${e}/${t}`,{cache:"no-cache",credentials:"include",keepalive:!0,...n});if(!r.ok){const{ok:e,status:t,statusText:n,headers:s}=r;throw console.error("SDK ZProxy call failed:",{ok:e,status:t,statusText:n,headers:Object.fromEntries([...s.entries()])}),new o("Point SDK request failed")}try{return await r.json()}catch(e){throw console.error("Point API response parsing error:",e),e}}catch(e){throw console.error("Point API call failed:",e),e}})(t,{method:"POST",body:n})};function d(e){return new Promise((t=>setTimeout(t,e)))}const w={},p={},u={},y="subscription_confirmation",S="subscription_cancellation",b="subscription_event",g="subscription_error",h="subscribeContractEvent",f="removeSubscriptionById",E=({type:e,params:{contract:t,event:o}={}})=>`${e}_${t}_${o}`,D=e=>p[e]||(p[e]=[]),P={},I=(e,{messageQueueSizeLimit:t=1e3}={})=>new Promise(((o,c)=>{if(void 0!==w[e])return void o(w[e]);const l=new WebSocket(e);l.onopen=()=>o(Object.assign(w[e]=l,{async subscribeToContractEvent(e){const t={type:h,params:e},o=E(t);P[o]=function(){let e=()=>{},t=()=>{};return Object.assign(new Promise(((o,n)=>{e=o,t=n})),{resolve:e,reject:t})}(),await l.send(JSON.stringify(t));const n=await Promise.race([P[o],(r=1e4,new Promise(((e,t)=>setTimeout((()=>t(new a("Subscription confirmation timeout"))),r))))]);var r;const s=D(n);return Object.assign((async()=>{for(;;)try{const e=u[n];if(e)throw e;if(s.length)return s.shift();await d(100)}catch(e){throw console.error("subscribed message error:",e),e}}),{unsubscribe:()=>l.send(JSON.stringify({type:f,params:{subscriptionId:n}}))})}})),l.onerror=e=>{for(const t in p)u[t]||(u[t]=new r(e.toString()))},l.onclose=t=>{delete w[e];for(const e in p)u[e]||(u[e]=new s(t.toString()));1e3===t.code?o(void 0):c()},l.onmessage=e=>{try{const{type:o,request:r,subscriptionId:s,data:a}=JSON.parse(e.data);switch(o){case y:{const e=E(r),{resolve:t,reject:o}=P[e]||{};"string"!=typeof s?"function"==typeof o&&o(new i(`Invalid subscription id "${s}" for request id: "${e}"`)):"function"==typeof t&&t(s);break}case S:s&&(console.info({type:o,request:r,subscriptionId:s,data:a}),delete p[s],delete u[s]);break;case b:if(s){const e=D(s);e.length>t?u[s]=new n("ZProxy WS message queue overflow"):e.push(a)}else console.error("Unable to identify subscription channel",{subscriptionId:s,request:r,data:a});break;case g:s?u[s]=new i(JSON.stringify(a)):console.error("Unable to identify subscription channel",{subscriptionId:s,request:r,data:a});break;default:console.error("Unsupported event type:",{type:o,request:r,subscriptionId:s,data:a})}}catch(e){console.log("Web Socket onmessage error:",e)}}}));return{version:t,status:{ping:()=>l.get("status/ping",void 0,{"wallet-token":"WALLETID-PASSCODE"})},contract:{load:({contract:e,...t})=>l.get(`contract/load/${e}`,t,{"wallet-token":"WALLETID-PASSCODE"}),call:e=>l.post("contract/call",e,{"wallet-token":"WALLETID-PASSCODE"}),send:e=>l.post("contract/send",e,{"wallet-token":"WALLETID-PASSCODE"}),events:e=>l.post("contract/events",e,{"wallet-token":"WALLETID-PASSCODE"}),async subscribe({contract:t,event:n,...r}){if("string"!=typeof t)throw new o(`Invalid contract ${t}`);if("string"!=typeof n)throw new o(`Invalid event ${n}`);const s=new URL(e);s.protocol="https:"===s.protocol?"wss:":"ws:";const a=await I(s.toString());if(!a)throw new o("Failed to establish web socket connection");return a.subscribeToContractEvent({contract:t,event:n,...r})}},storage:{postFile:e=>l.postFile("_storage/",e),getString:({id:e,...t})=>l.get(`storage/getString/${e}`,t,{"wallet-token":"WALLETID-PASSCODE"}),putString:e=>l.post("storage/putString",e,{"wallet-token":"WALLETID-PASSCODE"})},wallet:{address:()=>l.get("wallet/address"),hash:()=>l.get("wallet/hash"),publicKey:()=>l.get("wallet/publicKey",{},{"wallet-token":"WALLETID-PASSCODE"}),balance:()=>l.get("wallet/balance"),encryptData:({publicKey:e,data:t,...o})=>l.post("wallet/encryptData",{publicKey:e,data:t,...o},{"wallet-token":"WALLETID-PASSCODE"}),decryptData:({data:e,...t})=>l.post("wallet/decryptData",{data:e,...t},{"wallet-token":"WALLETID-PASSCODE"})},identity:{publicKeyByIdentity:({identity:e,...t})=>l.get(`identity/publicKeyByIdentity/${e}`,t,{"wallet-token":"WALLETID-PASSCODE"}),identityToOwner:({identity:e,...t})=>l.get(`identity/identityToOwner/${e}`,t,{"wallet-token":"WALLETID-PASSCODE"}),ownerToIdentity:({owner:e,...t})=>l.get(`identity/ownerToIdentity/${e}`,t,{"wallet-token":"WALLETID-PASSCODE"})}}};try{window.eval(`window.point = (${e.toString()})(window.location.origin, "0.0.10");`)}catch(e){console.error("Failed to inject point sdk: ",e)}})();
//# sourceMappingURL=index.js.map
